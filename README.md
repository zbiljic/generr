# generr

`generr` is a Go code generation tool that creates error-wrapping functions for methods of a specified type. It helps in standardizing error handling by generating functions that wrap existing errors with context about the method from which the error originated.

## Features

- Generates error-wrapping functions for methods of a given Go type.
- Allows customization of generated function names and error formats using `+generr` comments.
- Supports specifying custom parameters for the generated error functions.
- Integrates with `go generate` for easy automation.

## Installation

To install `generr`, you can use `go install`:

```bash
go install github.com/zbiljic/generr@latest
```

Ensure that your `GOPATH/bin` directory is in your system's `PATH` to easily access the `generr` executable.

## Usage

### Basic Usage

1. **Define your type and methods:**
   ```go
   package mypackage

   type MyService struct {
       // ...
   }

   func (s *MyService) DoSomething() error {
       // ...
       return fmt.Errorf("something failed")
   }

   func (s *MyService) AnotherAction(id string) error {
       // ...
       return fmt.Errorf("action %s failed", id)
   }
   ```

2. **Add a `//go:generate` directive to your file:**
   ```go
   //go:generate generr -type MyService
   package mypackage

   // ...
   ```
   This directive tells `go generate` to run `generr` for the `MyService` type in the current package.

3. **Run `go generate`:**
   ```bash
   go generate ./...
   ```
   This will create a file named `myservice_generr.go` (by default) in the same directory, containing the generated error functions.

### Generated Code Example

For the `MyService` example above, `generr` would produce something like:

```go
// Code generated by "generr"; DO NOT EDIT.

package mypackage

import "fmt"

// errDoSomething is an error function generated for MyService.DoSomething
func (*MyService) errDoSomething(err error) error {
	return fmt.Errorf("mypackage.DoSomething: %w", err)
}

// errAnotherAction is an error function generated for MyService.AnotherAction
func (*MyService) errAnotherAction(err error) error {
	return fmt.Errorf("mypackage.AnotherAction: %w", err)
}
```

You can then use these generated functions in your methods:

```go
func (s *MyService) DoSomething() error {
    if err := someOperation(); err != nil {
        return s.errDoSomething(err) // Use the generated error wrapper
    }
    return nil
}
```

### Customization with `+generr` Comments

You can customize the generated error functions by adding `+generr` comments to your method's documentation.

#### `format` Option

Change the format string used in `fmt.Errorf`.

```go
// +generr format="failed to process request: %w"
func (s *MyService) ProcessRequest() error {
    // ...
}
```

Generated function:
```go
func (*MyService) errProcessRequest(err error) error {
	return fmt.Errorf("failed to process request: %w", err)
}
```

#### `namesuffix` Option

Add a suffix to the generated function name.

```go
// +generr namesuffix=WithContext
func (s *MyService) PerformTask() error {
    // ...
}
```

Generated function:
```go
func (*MyService) errPerformTaskWithContext(err error) error {
	return fmt.Errorf("mypackage.PerformTask: %w", err)
}
```

#### `params` Option

Define custom parameters for the generated error function. The `error` parameter is automatically added if not specified.
You can define named parameters by putting the name in parentheses `(name)`.

```go
// +generr params="string(id);error"
func (s *MyService) DeleteItem(itemId string) error {
    // ...
}
```

Generated function:
```go
func (*MyService) errDeleteItem(id string, err error) error {
	return fmt.Errorf("mypackage.DeleteItem: %s: %w", id, err)
}
```

Multiple options can be combined using commas:

```go
// +generr format="user %s not found: %w",params="string(userID);error"
func (s *MyService) GetUser(userID string) error {
    // ...
}
```

#### Multiple Generated Functions per Method

You can define multiple `+generr` lines for a single method, each generating a different error-wrapping function.

```go
// +generr
// +generr namesuffix=NotFound,format="item not found: %w"
// +generr namesuffix=Invalid,params="string(reason);error",format="item is invalid (%s): %w"
func (s *MyService) GetItem() error {
    // ...
}
```

This will generate:
- `errGetItem(err error)`
- `errGetItemNotFound(err error)`
- `errGetItemInvalid(reason string, err error)`

#### `skip` Option

To explicitly prevent `generr` from generating an error function for a specific method, use `+generr:skip`.

```go
// +generr:skip
func (s *MyService) InternalHelper() error {
    // This method will be ignored by generr
    return nil
}
```

### Command-line Flags

- `-type <name>`: **(Required)** Comma-separated list of type names for which to generate error functions.
- `-output <file>`: Output file name. Defaults to `srcdir/<type>_generr.go`.
- `-trimprefix <prefix>`: Trim the specified `prefix` from the generated constant namespace. This is useful when your module path includes a common prefix that you don't want in the error strings.
- `-tags <tags>`: Comma-separated list of build tags to apply when parsing the package.
- `-exported`: Generate error functions only for exported methods (methods starting with an uppercase letter).

### Example `go:generate` Directives

```go
// Generate for MyService in the current directory:
//go:generate generr -type MyService

// Generate for multiple types:
//go:generate generr -type MyService,AnotherStruct

// Generate with a custom output file name:
//go:generate generr -type MyService -output errors.go

// Generate and trim a prefix from the module path in the error string:
//go:generate generr -type MyService -trimprefix github.com/yourorg/yourmodule

// Generate only for exported methods:
//go:generate generr -type MyService -exported
```

## Development

### Building `generr`

```bash
make install
```

### Linting and Formatting

```bash
make lint
make gofmt
```

## Contributing

Feel free to open issues or submit pull requests.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.
