package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

var (
	typeNames  = flag.String("type", "", "comma-separated list of type names; must be set")
	output     = flag.String("output", "", "output file name; default srcdir/<type>_generr.go")
	trimprefix = flag.String("trimprefix", "", "trim the `prefix` from the generated constant namespace")
	buildTags  = flag.String("tags", "", "comma-separated list of build tags to apply")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of generr:\n")
	fmt.Fprintf(os.Stderr, "\tgenerr [flags] -type T [directory]\n")
	fmt.Fprintf(os.Stderr, "\tgenerr [flags] -type T files... # Must be a single package\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("generr: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*typeNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	types := strings.Split(*typeNames, ",")
	var tags []string
	if len(*buildTags) > 0 {
		tags = strings.Split(*buildTags, ",")
	}

	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	// Parse the package once.
	var dir string
	g := Generator{
		trimPrefix: *trimprefix,
	}
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		if len(tags) != 0 {
			log.Fatal("-tags option applies only to directories, not when files are specified")
		}
		dir = filepath.Dir(args[0])
	}

	g.parsePackage(args, tags)

	// Print the header and package clause.
	g.Printf("// Code generated by \"generr\"; DO NOT EDIT.\n")
	g.Printf("\n")
	g.Printf("package %s", g.pkg.name)
	g.Printf("\n")
	g.Printf("import \"fmt\"\n") // Used by all methods.

	// Run generate for each type.
	for _, typeName := range types {
		g.generate(typeName)
	}

	// Format the output.
	src := g.format()

	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_generr.go", types[0])
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}
	err := os.WriteFile(outputName, src, 0o644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
	pkg *Package     // Package we are scanning.

	trimPrefix string

	logf func(format string, args ...interface{}) // test logging hook; nil when not testing
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// File holds a single parsed file and associated data.
type File struct {
	pkg  *Package  // Package to which this file belongs.
	file *ast.File // Parsed AST.
	// These fields are reset for each type being generated.
	typeName  string     // Name of the struct type.
	functions []Function // Accumulator for functions of that struct.
}

type Package struct {
	name      string
	defs      map[*ast.Ident]types.Object
	namespace string
	files     []*File
}

func pkgLoadMode() packages.LoadMode {
	mode := packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax
	mode |= packages.NeedModule
	return mode
}

// parsePackage analyzes the single package constructed from the patterns and tags.
// parsePackage exits if there is an error.
func (g *Generator) parsePackage(patterns, tags []string) {
	cfg := &packages.Config{
		Mode:       pkgLoadMode(),
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
		Logf:       g.logf,
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages matching %v", len(pkgs), strings.Join(patterns, " "))
	}
	g.addPackage(pkgs[0])
}

// addPackage adds a type checked Package and its syntax files to the generator.
func (g *Generator) addPackage(pkg *packages.Package) {
	// The namespace of the operations.
	ns := ""

	if pkg.Module != nil && strings.HasPrefix(pkg.PkgPath, pkg.Module.Path) {
		ns = strings.TrimPrefix(pkg.PkgPath, pkg.Module.Path)
		ns = strings.TrimPrefix(ns, "/")
		if g.trimPrefix != "" {
			ns = strings.TrimPrefix(ns, g.trimPrefix)
			ns = strings.TrimPrefix(ns, "/")
		}
	} else {
		ns = pkg.Name
	}

	g.pkg = &Package{
		name:      pkg.Name,
		defs:      pkg.TypesInfo.Defs,
		namespace: ns,
		files:     make([]*File, len(pkg.Syntax)),
	}

	for i, file := range pkg.Syntax {
		g.pkg.files[i] = &File{
			file: file,
			pkg:  g.pkg,
		}
	}
}

// generate produces the String method for the named type.
func (g *Generator) generate(typeName string) {
	functions := make([]Function, 0, 100)
	for _, file := range g.pkg.files {
		// Set the state for this run of the walker.
		file.typeName = typeName
		file.functions = nil
		if file.file != nil {
			ast.Inspect(file.file, file.funcDecl)
			functions = append(functions, file.functions...)
		}
	}

	if len(functions) == 0 {
		log.Fatalf("no functions defined for type %s", typeName)
	}

	// Generate code.
	for _, fn := range functions {
		var funcParams []jen.Code
		var callParams []jen.Code

		if len(fn.opts) == 0 {
			funcParams = []jen.Code{jen.Id("err").Error()}
			callParams = []jen.Code{
				jen.Lit("%s: %w"),
				jen.Lit(fn.String()),
				jen.Id("err"),
			}
			g.generateSingle(typeName, fn.name, "", funcParams, callParams)
		} else {
			for i, opt := range fn.opts {
				fnNameSuffix := ""
				if i > 0 {
					fnNameSuffix = strconv.FormatInt(int64(i), 10)
				}

				funcParams = []jen.Code{jen.Id("err").Error()}
				callParams = []jen.Code{
					jen.Lit("%s: %w"),
					jen.Lit(fn.String()),
					jen.Id("err"),
				}

				if opt == "" {
					g.generateSingle(typeName, fn.name, fnNameSuffix, funcParams, callParams)
					continue
				}

				// Split on configuration options
				markers := strings.Split(opt, ",")

				for _, marker := range markers {
					values := strings.Split(marker, "=")

					if len(values) == 1 {
						log.Fatalf("invalid marker '%s' for type %s", marker, typeName)
					}

					switch values[0] {
					case "format":
						callParams[0] = jen.Lit(values[1])
					case "namesuffix":
						fnNameSuffix = titleCase(values[1])
					case "params":
						extraParams := strings.Split(values[1], ";")

						// remove last parameter
						funcParams = funcParams[:len(funcParams)-1]
						callParams = callParams[:len(callParams)-1]

						for j, param := range extraParams {
							paramName := fmt.Sprintf("p%d", j)
							paramType := param

							// defaults
							if paramType == "error" {
								paramName = "err"
							}

							// check for named parameter
							if idx := strings.Index(param, "("); idx > 0 {
								if !strings.Contains(param, ")") {
									log.Fatalf("invalid param '%s' for type %s", param, typeName)
								}

								paramName = strings.Trim(param[idx:], "()")
								paramType = param[:idx]
							}

							funcParams = append(funcParams,
								jen.Id(paramName).Op(paramType),
							)
							callParams = append(callParams,
								jen.Id(paramName),
							)
						}
					}
				}

				g.generateSingle(typeName, fn.name, fnNameSuffix, funcParams, callParams)
			}
		}
	}
}

func (g *Generator) generateSingle(
	typeName, funcName, funcNameSuffix string,
	funcParams, callParams []jen.Code,
) {
	errFunctionName := fmt.Sprintf("err%s%s", titleCase(funcName), funcNameSuffix)

	g.Printf("%#v", jen.Commentf("// %s is an error function generated for %s.%s",
		errFunctionName, typeName, funcName))
	g.Printf("\n")

	c := jen.Func().
		Params(jen.Op("*").Id(typeName)).
		Id(errFunctionName).
		Params(funcParams...).
		Parens(jen.Error()).
		Block(
			jen.Return().Qual("fmt", "Errorf").Call(callParams...),
		)
	g.Printf("%#v", c)
	g.Printf("\n")
	g.Printf("\n")
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

// Function represents a discovered function.
type Function struct {
	name string   // The name of the function.
	opts []string // The provided options for generator.
	str  string   // The unique string representation.
}

func (f *Function) String() string {
	return f.str
}

// genDecl processes one declaration clause.
func (f *File) funcDecl(node ast.Node) bool {
	decl, ok := node.(*ast.FuncDecl)

	if !ok || decl.Recv == nil {
		// We only care about type declarations.
		return true
	}

	// The name of the identifier for the node.
	typ := ""

	// Loop over the function field list.
	for _, field := range decl.Recv.List {
		name := decl.Name.Name

		switch ft := field.Type.(type) {
		case *ast.Ident:
			typ = ft.Name
		case *ast.StarExpr:
			if ft.X != nil {
				ident, ok := ft.X.(*ast.Ident)
				if !ok {
					continue
				}
				typ = ident.Name
			}
		}

		if typ != f.typeName {
			// This is not the type we're looking for.
			continue
		}

		if strings.HasPrefix(name, "err") {
			// Do not create for error functions.
			continue
		}

		fn := Function{
			name: name,
			str:  strings.Join([]string{f.pkg.namespace, name}, "."),
		}

		if decl.Doc != nil {
			for _, comment := range decl.Doc.List {
				if idx := strings.Index(comment.Text, "+generr"); idx > 0 {
					if len(comment.Text) >= idx+8 {
						options := comment.Text[idx+8:]
						fn.opts = append(fn.opts, options)
					} else {
						fn.opts = append(fn.opts, "")
					}
				}
			}
		}

		f.functions = append(f.functions, fn)
	}

	return false
}

// Helpers

func titleCase(s string) string {
	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}
